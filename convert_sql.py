import re
import sys

def convert_mysql_to_postgres(input_file, output_file):
    with open(input_file, 'r', encoding='utf-8', errors='ignore') as f_in, \
         open(output_file, 'w', encoding='utf-8') as f_out:

        f_out.write("SET standard_conforming_strings = 'off';\n")
        f_out.write("SET backslash_quote = 'on';\n")
        f_out.write("BEGIN;\n")
        
        buffer = []
        
        for line in f_in:
            line_content = line.strip()
            
            if not buffer and not line_content:
                continue
            
            if not buffer and (line_content.startswith('--') or line_content.startswith('/*')):
                continue
                
            buffer.append(line)
            
            if line_content.endswith(';'):
                statement = "".join(buffer)
                buffer = []
                
                converted_stmts = process_statement(statement)
                if converted_stmts:
                     for cs in converted_stmts:
                        f_out.write(cs + "\n")
        
        if buffer:
            statement = "".join(buffer)
            converted_stmts = process_statement(statement)
            if converted_stmts:
                 for cs in converted_stmts:
                    f_out.write(cs + "\n")

        f_out.write("COMMIT;\n")

def process_statement(stmt):
    stmt_clean = stmt.strip()
    
    if stmt_clean.upper().startswith('DROP TABLE'):
        stmt = stmt.replace('`', '"')
        return [stmt]

    if stmt_clean.upper().startswith('CREATE TABLE'):
        return [convert_create_table(stmt)]
    
    if stmt_clean.upper().startswith('INSERT INTO'):
        return [convert_insert(stmt)]
    
    if stmt_clean.upper().startswith('ALTER TABLE'):
         return convert_alter(stmt)
         
    return []

def convert_create_table(create_stmt):
    # Normalize backticks first to simplify regex
    create_stmt = create_stmt.replace('`', '"')

    # Remove strict table name matching, focus on content conversion
    # Ints
    create_stmt = re.sub(r'tinyint\(\d+\)', 'SMALLINT', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'smallint\(\d+\)', 'SMALLINT', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'mediumint\(\d+\)', 'INTEGER', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'bigint\(\d+\)', 'BIGINT', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'\bint\(\d+\)', 'INTEGER', create_stmt, flags=re.IGNORECASE)
    
    # Float/Blob/Text/Datetime
    create_stmt = re.sub(r'\bdouble\b', 'DOUBLE PRECISION', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'\bfloat\b', 'REAL', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'\bblob\b', 'BYTEA', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'tinyblob', 'BYTEA', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'mediumblob', 'BYTEA', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'longblob', 'BYTEA', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'binary\(\d+\)', 'BYTEA', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'varbinary\(\d+\)', 'BYTEA', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'tinytext', 'TEXT', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'mediumtext', 'TEXT', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'longtext', 'TEXT', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'datetime', 'TIMESTAMP', create_stmt, flags=re.IGNORECASE)

    # Relax constraints: 0000-00-00 -> NULL might violate NOT NULL
    # So remove NOT NULL from date/time types
    create_stmt = re.sub(r'(TIMESTAMP|DATE)\s+NOT NULL', r'\1', create_stmt, flags=re.IGNORECASE)
    
    create_stmt = create_stmt.replace("DEFAULT '0000-00-00 00:00:00'", "DEFAULT NULL")
    create_stmt = create_stmt.replace("DEFAULT '0000-00-00'", "DEFAULT NULL")
    
    # Validation: valid PostgreSQL does not allow "NOT NULL DEFAULT NULL"
    create_stmt = create_stmt.replace("NOT NULL DEFAULT NULL", "DEFAULT NULL")

    create_stmt = re.sub(r'UNSIGNED', '', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'CHARACTER SET [\w\d]+', '', create_stmt, flags=re.IGNORECASE)
    create_stmt = re.sub(r'COLLATE [\w\d_]+', '', create_stmt, flags=re.IGNORECASE)
    
    # Remove table options after last paren
    last_paren_index = create_stmt.rfind(')')
    if last_paren_index != -1:
        # Check if there's anything meaningful after it
        tail = create_stmt[last_paren_index+1:]
        if 'ENGINE' in tail.upper() or 'CHARSET' in tail.upper():
             create_stmt = create_stmt[:last_paren_index+1] + ';'
             
    create_stmt = re.sub(r'AUTO_INCREMENT', 'GENERATED BY DEFAULT AS IDENTITY', create_stmt, flags=re.IGNORECASE)
    
    return create_stmt

def convert_insert(insert_stmt):
    insert_stmt = insert_stmt.replace('`', '"')
    insert_stmt = insert_stmt.replace("'0000-00-00'", "NULL")
    insert_stmt = insert_stmt.replace("'0000-00-00 00:00:00'", "NULL")
    return insert_stmt

def convert_alter(alter_stmt):
    alter_stmt = alter_stmt.replace('`', '"')
    
    # More robust table name extraction
    match = re.search(r'ALTER TABLE\s+"?(\w+)"?', alter_stmt, re.IGNORECASE)
    if not match:
        return [alter_stmt] # Fallback
    table_name = match.group(1)
    
    match_end = match.end()
    body = alter_stmt[match_end:].strip().rstrip(';')
    
    # Clean up body to single line for easier regex
    body_clean = re.sub(r'\s+', ' ', body)
    
    output_stmts = []
    
    # Add Primary Key
    pk_match = re.search(r'ADD PRIMARY KEY \((.*?)\)', body_clean, re.IGNORECASE)
    if pk_match:
        cols = pk_match.group(1)
        output_stmts.append(f'ALTER TABLE "{table_name}" ADD PRIMARY KEY ({cols});')
        
    # Add Unique Keys - relaxed regex
    # Matches: ADD UNIQUE KEY "name" (...) or ADD UNIQUE KEY name (...)
    for uk_match in re.finditer(r'ADD UNIQUE KEY\s+"?(\w+)"?\s+\((.*?)\)', body_clean, re.IGNORECASE):
        key_name = uk_match.group(1)
        cols = uk_match.group(2)
        output_stmts.append(f'ALTER TABLE "{table_name}" ADD CONSTRAINT "{table_name}_{key_name}" UNIQUE ({cols});')
        
    # Add Indices - relaxed regex
    # Matches: ADD KEY "name" (...) or ADD KEY name (...)
    for k_match in re.finditer(r'ADD KEY\s+"?(\w+)"?\s+\((.*?)\)', body_clean, re.IGNORECASE):
        start_index = k_match.start()
        # Lookbehind to ensure not UNIQUE
        preceding = body_clean[max(0, start_index-10):start_index]
        if 'UNIQUE' in preceding.upper():
            continue
            
        key_name = k_match.group(1)
        cols = k_match.group(2)
        output_stmts.append(f'CREATE INDEX "{table_name}_{key_name}" ON "{table_name}" ({cols});')
        
    # Modify Auto Increment
    # MODIFY "col" ... AUTO_INCREMENT
    for mod_match in re.finditer(r'MODIFY\s+"?(\w+)"?.*?AUTO_INCREMENT', body_clean, re.IGNORECASE):
        col_name = mod_match.group(1)
        output_stmts.append(f'ALTER TABLE "{table_name}" ALTER COLUMN "{col_name}" ADD GENERATED BY DEFAULT AS IDENTITY;')

    # If we found nothing but it looked like an ALTER TABLE, we might have failed parsing.
    # But usually we find something. If regular ALTER (like adding columns) we might miss it here
    # but the dump usually only has keys/auto_increment in ALTER statements at the end.
    
    if not output_stmts:
        # If we couldn't parse it into components, assume we can't handle it or it's empty.
        # Returning original might cause grammar error if syntax is MySQL specific.
        # Let's return commented out to be safe if we can't parse?
        # Or returns empty.
        # But wait, if it was "ALTER TABLE t AUTO_INCREMENT=5", we just want to ignore it.
        # So returning empty is correct for ignored attributes.
        pass
        
    return output_stmts

if __name__ == "__main__":
    convert_mysql_to_postgres(sys.argv[1], sys.argv[2])
